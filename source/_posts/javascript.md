---
title: javascript
date: 2022-02-20 16:29:06
tags: [javascript]
categories: 'javascript'
---

# 闭包
 闭包是能够读取其他函数内部的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。

# 类的创建和继承

# 事件流
HTML中与`javascript`交互是通过**事件驱动**来实现的，例如鼠标点击事件`onclick`、页面的滚动事件`onscroll`等等，可以向文档或者文档中的元素 添加 事件侦听器 来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下 **“事件流”** 的概念。

> 事件流描述的是从页面中接收事件的顺序，DOM2级事件流包括下面几个阶段
* 事件捕获阶段
* 处于目标阶段
* 事件冒泡阶段

addEventListener: addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：
1. 要处理的事件名
2. 作为事件处理程序的函数
3. 一个布尔值。
最后这个布尔值参数如果是true，表示在**捕获阶段调用事件处理程序**；如果是false，表示在**冒泡阶段调用事件处理程序**。

> IE只支持事件冒泡


# js的各种位置

>比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？

* `clientHeight`：可视区域的高度，不包含border和滚动条
* `offsetHeight`：可视区域的高度，包含了border和滚动条
* `scrollHeight`：所有区域的高度，包含了因为滚动被隐藏的部分。
* `clientTop`：边框border的厚度，在未指定的情况下一般为0
* `scrollTop`：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。

# 垃圾回收机制
必要性： 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：

```js
var a="hello world";
var b="world";
var a=b; //这时，会释放掉"hello world"，释放内存以便再引用
```

> 垃圾回收的方法：标记清除、计数引用。

## 标记清除

这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。

垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。

## 计数引用

另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。

用引用计数法会存在内存泄露，下面来看原因：

```js
function problem() {
var objA = new Object();
var objB = new Object();
objA.someOtherObject = objB;
objB.anotherObject = objA;
}
```

> 在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。